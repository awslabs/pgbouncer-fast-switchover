diff --git a/src/objects.c b/src/objects.c
index 3d3702d..bc691d7 100644
--- a/src/objects.c
+++ b/src/objects.c
@@ -708,14 +708,20 @@ PgPool *get_pool(PgDatabase *db, PgUser *user)
 {
 	struct List *item;
 	PgPool *pool;
+	PgPool *global_writer = NULL;
 
 	if (!db || !user)
 		return NULL;
 
 	list_for_each(item, &user->pool_list) {
 		pool = container_of(item, PgPool, map_head);
-		if (pool->db == db)
+		if (pool->db == db) {
+			global_writer = get_global_writer(pool);
+			if (global_writer)
+				return global_writer;
+
 			return pool;
+		}
 	}
 
 	return new_pool(db, user);
@@ -1072,6 +1078,10 @@ bool life_over(PgSocket *server)
 	usec_t age = now - server->connect_time;
 	usec_t last_kill = now - pool->last_lifetime_disconnect;
 
+	// never close the pools when using fast switchovers
+	if (pool->db && pool->db->topology_query)
+		return false;
+
 	if (age < cf_server_lifetime)
 		return false;
 
@@ -1526,6 +1536,8 @@ static void dns_connect(struct PgSocket *server)
 	int sa_len;
 	int res;
 	char *host_copy = NULL;
+	int port = db->port;
+	char *token;	
 
 	/* host list? */
 	if (db->host && strchr(db->host, ',')) {
@@ -1540,7 +1552,20 @@ static void dns_connect(struct PgSocket *server)
 		for (host = strtok(host_copy, ","), n = 0; host; host = strtok(NULL, ","), n++)
 			if (server->pool->rrcounter % count == n)
 				break;
+		
+		/* if host contains port then change port and remove port part from host */
+		// Use strtok to split the string by ':'
+		token = strtok(input, ":");
+		if (token != NULL) {
+			host = token;
+			token = strtok(NULL, ":");
+			if (token != NULL) {
+				port = atoi(token); // Convert port string to integer
+			}
+		}
+
 		Assert(host);
+		Assert(port);
 
 		server->pool->rrcounter++;
 	} else {
@@ -1559,7 +1584,7 @@ static void dns_connect(struct PgSocket *server)
 			goto cleanup;
 		}
 		snprintf(sa_un.sun_path, sizeof(sa_un.sun_path),
-			 "%s/.s.PGSQL.%d", unix_dir, db->port);
+			 "%s/.s.PGSQL.%d", unix_dir, port);
 		slog_noise(server, "unix socket: %s", sa_un.sun_path);
 		if (unix_dir[0] == '@') {
 			/*
@@ -1579,7 +1604,7 @@ static void dns_connect(struct PgSocket *server)
 		memset(&sa_in6, 0, sizeof(sa_in6));
 		sa_in6.sin6_family = AF_INET6;
 		res = inet_pton(AF_INET6, host, &sa_in6.sin6_addr);
-		sa_in6.sin6_port = htons(db->port);
+		sa_in6.sin6_port = htons(port);
 		sa = (struct sockaddr *)&sa_in6;
 		sa_len = sizeof(sa_in6);
 	} else {/* else try IPv4 */
@@ -1587,7 +1612,7 @@ static void dns_connect(struct PgSocket *server)
 		memset(&sa_in, 0, sizeof(sa_in));
 		sa_in.sin_family = AF_INET;
 		res = inet_pton(AF_INET, host, &sa_in.sin_addr);
-		sa_in.sin_port = htons(db->port);
+		sa_in.sin_port = htons(port);
 		sa = (struct sockaddr *)&sa_in;
 		sa_len = sizeof(sa_in);
 	}
@@ -1606,6 +1631,7 @@ static void dns_connect(struct PgSocket *server)
 	connect_server(server, sa, sa_len);
 cleanup:
 	free(host_copy);
+	free(token);
 }
 
 PgSocket *compare_connections_by_time(PgSocket *lhs, PgSocket *rhs)
@@ -1844,6 +1870,8 @@ PgSocket *accept_client(int sock, bool is_unix)
 /* client managed to authenticate, send welcome msg and accept queries */
 bool finish_client_login(PgSocket *client)
 {
+	PgPool *global_writer = get_global_writer(client->pool);
+
 	if (client->db->fake) {
 		if (cf_log_connections)
 			slog_info(client, "login failed: db=%s user=%s", client->db->name, client->login_user->name);
@@ -1858,6 +1886,21 @@ bool finish_client_login(PgSocket *client)
 
 	switch (client->state) {
 	case CL_LOGIN:
+		if (client->pool->db->admin) {
+			log_debug("finish_client_login: admin_db: nothing to do");
+		} else if (!fast_switchover) {
+			log_debug("finish_client_login: not using fast switchovers");
+		} else if (!client->pool->db->topology_query) {
+			log_debug("finish_client_login: no topology query, so not using fast switchover");
+		} else if (global_writer) {
+			log_debug("finish_client_login: global writer is set, so let's use the cached value: %s", global_writer->db->name);
+			if (client->pool != global_writer && !set_pool(client, global_writer->db->name, client->login_user->name, client->login_user->passwd, true)) {
+				log_error("could not set pool to: %s", global_writer->db->name);
+				return false;
+			}
+		} else {
+			log_debug("finish_client_login: done...activating client");
+		}
 		change_client_state(client, CL_ACTIVE);
 	case CL_ACTIVE:
 		break;
